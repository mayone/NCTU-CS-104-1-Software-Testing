#include <cstdlib>
#include "triangle.h"
#include "gtest/gtest.h"

TEST(TriangleTest, C0_Coverage) {
	EXPECT_EQ(OUT_OF_RANGE, Triangle(LOWER_BOUND-1, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(UPPER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(EQUILATERAL, Triangle(VALID_VALUE, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(ISOSCELES, Triangle(LOWER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(SCALENE, Triangle(VALID_VALUE-1, VALID_VALUE, VALID_VALUE+1));
}

TEST(TriangleTest, C1_Coverage) {
	// Just the same as C0 since every branch is traversed.
	EXPECT_EQ(OUT_OF_RANGE, Triangle(LOWER_BOUND-1, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(UPPER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(EQUILATERAL, Triangle(VALID_VALUE, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(ISOSCELES, Triangle(LOWER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(SCALENE, Triangle(VALID_VALUE-1, VALID_VALUE, VALID_VALUE+1));
}

TEST(TriangleTest, C2_Coverage) {
	// Just the same as C0 and C1 since there is no loop.
	EXPECT_EQ(OUT_OF_RANGE, Triangle(LOWER_BOUND-1, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(UPPER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(EQUILATERAL, Triangle(VALID_VALUE, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(ISOSCELES, Triangle(LOWER_BOUND, VALID_VALUE, VALID_VALUE));
	EXPECT_EQ(SCALENE, Triangle(VALID_VALUE-1, VALID_VALUE, VALID_VALUE+1));
}

TEST(TriangleTest, MCDC_Coverage) {
	// Out of range
	EXPECT_EQ(OUT_OF_RANGE, Triangle(LOWER_BOUND-1, VALID_VALUE, VALID_VALUE));	// TF FF FF
	EXPECT_EQ(OUT_OF_RANGE, Triangle(UPPER_BOUND+1, VALID_VALUE, VALID_VALUE));	// FT FF FF
	EXPECT_EQ(OUT_OF_RANGE, Triangle(VALID_VALUE, LOWER_BOUND-1, VALID_VALUE));	// FF TF FF
	EXPECT_EQ(OUT_OF_RANGE, Triangle(VALID_VALUE, UPPER_BOUND+1, VALID_VALUE));	// FF FT FF
	EXPECT_EQ(OUT_OF_RANGE, Triangle(VALID_VALUE, VALID_VALUE, LOWER_BOUND-1));	// FF FF TF
	EXPECT_EQ(OUT_OF_RANGE, Triangle(VALID_VALUE, VALID_VALUE, UPPER_BOUND+1));	// FF FF FT
	// Not a triangle
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(LOWER_BOUND, LOWER_BOUND, LOWER_BOUND+1));	// T F F
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(LOWER_BOUND+1, LOWER_BOUND, LOWER_BOUND));	// F T F
	EXPECT_EQ(NOT_A_TRIANGLE, Triangle(LOWER_BOUND, LOWER_BOUND+1, LOWER_BOUND));	// F F T
	// Equilateral
	EXPECT_EQ(EQUILATERAL, Triangle(VALID_VALUE, VALID_VALUE, VALID_VALUE));
	// Isosceles
	EXPECT_EQ(ISOSCELES, Triangle(VALID_VALUE, VALID_VALUE, LOWER_BOUND));	// T F F
	EXPECT_EQ(ISOSCELES, Triangle(LOWER_BOUND, VALID_VALUE, VALID_VALUE));	// F T F
	EXPECT_EQ(ISOSCELES, Triangle(VALID_VALUE, LOWER_BOUND, VALID_VALUE));	// F F T
	// Scalene
	EXPECT_EQ(SCALENE, Triangle(VALID_VALUE-1, VALID_VALUE, VALID_VALUE+1));
}

int main(int argc, char **argv) {
	::testing::InitGoogleTest(&argc, argv);
	if (argc > 1) {
		switch (atoi(argv[1])) {
			case 0:
				::testing::GTEST_FLAG(filter) = "*.C0_Coverage";
				break;
			case 1:
				::testing::GTEST_FLAG(filter) = "*.C1_Coverage";
				break;
			case 2:
				::testing::GTEST_FLAG(filter) = "*.C2_Coverage";
				break;
			case 3:
				::testing::GTEST_FLAG(filter) = "*.MCDC_Coverage";
				break;
			default:
				break;
		}
	}
	return RUN_ALL_TESTS();
}